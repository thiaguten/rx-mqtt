plugins {
    // Add plugin, but do not apply it.
    id 'com.github.hierynomus.license' version '0.14.0' apply false
    id 'com.github.ben-manes.versions' version '0.17.0' apply false
    id 'com.github.kt3k.coveralls' version '2.8.2' apply false
}

apply from: "$rootDir/dependencies.gradle"

apply plugin: 'com.github.kt3k.coveralls'

allprojects {
    apply plugin: 'base'
    apply plugin: 'jacoco'

    group 'br.com.thiaguten'
    version '0.1.2-SNAPSHOT'
//    buildDir = "/mnt/ramdisk/${rootProject.name}/${project.name}"

    ext {
        jdkVersion = JavaVersion.VERSION_1_8
        repositoryName = 'rx-mqtt'
        repositoryOwner = 'thiaguten'
        isReleaseVersion = (project.version ==~ /(\d+\.\d+\.\d+)/)
        sonatypeUsername = project.hasProperty('ossrhUsername') ? rootProject.ossrhUsername : ''
        sonatypePassword = project.hasProperty('ossrhPassword') ? rootProject.ossrhPassword : ''
        sonatypeUrl = isReleaseVersion ? 'https://oss.sonatype.org/service/local/staging/deploy/maven2/' : 'https://oss.sonatype.org/content/repositories/snapshots/'
    }

    jacoco {
        toolVersion = '0.8.0'
    }

    repositories {
        jcenter()
        mavenCentral()
    }
}

subprojects {
    apply plugin: 'pmd'
    apply plugin: 'idea'
    apply plugin: 'maven'
    apply plugin: 'signing'
    apply plugin: 'findbugs'
    apply plugin: 'checkstyle'
    apply plugin: 'java-library'
    apply plugin: 'com.github.hierynomus.license'
    apply plugin: 'com.github.ben-manes.versions'

    sourceCompatibility = jdkVersion
    targetCompatibility = jdkVersion

    idea {
        module {
            downloadSources = false
            downloadJavadoc = false
        }
    }

    tasks.withType(JavaCompile) {
        options.with {
            encoding = 'UTF-8'
            compilerArgs << '-Xlint:all'
            fork = true
            incremental = true
        }
    }

    task wrapper(type: Wrapper) {
        description = 'Generates gradlew[.bat] scripts'
        gradleVersion = '4.5'
    }

    dependencies {
        testImplementation libs.junit
        testImplementation libs.mockito_core
        testImplementation libs.assertj_core
    }

    license {
        header = rootProject.file('etc/license/HEADER')
        strictCheck = true
        ignoreFailures = false
        skipExistingHeaders = true
        ext.name = 'Thiago Gutenberg Carvalho da Costa'
        ext.email = 'thiaguten@gmail.com'
        ext.year = Calendar.getInstance().get(Calendar.YEAR)
        mapping {
            java = 'SLASHSTAR_STYLE'
        }
    }

    checkstyle {
        toolVersion = '8.7'
        showViolations = true
        ignoreFailures = false
        sourceSets = [sourceSets.main]
        configFile = rootProject.file('etc/config/checkstyle.xml')
    }

    tasks.withType(Checkstyle) {
        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

    findbugs {
        toolVersion = '3.0.1'
        ignoreFailures = true
        effort = 'max'
        reportLevel = 'high'
        sourceSets = [sourceSets.main]
    }

    tasks.withType(FindBugs) {
        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

    pmd {
        toolVersion = '6.0.1'
        consoleOutput = true
        ignoreFailures = true
        sourceSets = [sourceSets.main]
    }

    tasks.withType(Pmd) {
        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

    jacocoTestReport {
        group = 'Coverage reports'
        description = 'Generates a test coverage report for a project'

        reports {
            csv.enabled = false
            html.enabled = true
            xml.enabled = true // coveralls plugin depends on xml format report
        }
    }

    task jacocoMerge(type: JacocoMerge) {
        executionData tasks.withType(Test)

        doFirst {
            executionData = files(executionData.findAll { it.exists() })
        }
    }

    javadoc {
        failOnError = true
        options.author = true
        options.encoding = 'UTF-8'
        options.header = project.name
        options.memberLevel = JavadocMemberLevel.PROTECTED
        if (JavaVersion.current().isJava8Compatible()) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }

    task sourceJar(type: Jar, dependsOn: classes) {
        classifier 'sources'
        from sourceSets.main.allSource
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier 'javadoc'
        from javadoc.destinationDir
    }

    artifacts {
        archives jar
        archives sourceJar
        archives javadocJar
    }

    signing {
        required { isReleaseVersion && gradle.taskGraph.hasTask('uploadArchives') }
        useGpgCmd()
        sign configurations.archives
    }

    uploadArchives {
        repositories {
            mavenDeployer {
                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

                repository(url: sonatypeUrl) {
                    authentication(userName: sonatypeUsername, password: sonatypePassword)
                }

                pom.project {
                    packaging 'jar'
                    name project.name
                    description project.description
                    url "https://github.com/${repositoryOwner}/${repositoryName}"

                    inceptionYear '2017'

                    scm {
                        url "https://github.com/${repositoryOwner}/${repositoryName}"
                        connection "scm:git:git@github.com:${repositoryOwner}/${repositoryName}.git"
                        developerConnection "scm:git:git@github.com:${repositoryOwner}/${repositoryName}.git"
                        tag 'HEAD'
                    }

                    licenses {
                        license {
                            name 'The Apache Software License, Version 2.0'
                            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                            distribution 'repo'
                        }
                    }

                    developers {
                        developer {
                            id 'thiaguten'
                            name 'Thiago Gutenberg Carvalho da Costa'
                            email 'thiaguten@gmail.com'
                        }
                    }
                }
            }
        }
    }
}

// Only report code coverage for projects that are distributed
def publishedProjects = subprojects.findAll { it.path != ':rx-mqtt-api' }

task jacocoMerge(type: JacocoMerge) {
    publishedProjects.each { subproject ->
        executionData subproject.tasks.withType(Test)
    }
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
}

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'
    dependsOn publishedProjects.test, jacocoMerge
    additionalSourceDirs = files(publishedProjects.sourceSets.main.allSource.srcDirs)
    sourceDirectories = files(publishedProjects.sourceSets.main.allSource.srcDirs)
    classDirectories = files(publishedProjects.sourceSets.main.output)
    executionData jacocoMerge.destinationFile
    reports {
        csv.enabled = false
        html.enabled = true // human readable
        xml.enabled = true // coveralls plugin depends on xml format report
//        xml.destination file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
    }
}

coveralls {
    sourceDirs = publishedProjects.sourceSets.main.allSource.srcDirs.flatten()
    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
}

tasks.coveralls {
    group = 'Coverage reports'
    description = 'Uploads the aggregated coverage report to Coveralls'
    dependsOn jacocoRootReport
    onlyIf { System.env.'CI' }
}
